#!/usr/bin/env python3
# For developing this script, use `make rfcs`. That requires the `rfc` repo cloned (see `RFCS_DIR` variable in the Makefile).
import argparse
import datetime
import json
import os
import re
import shutil
import subprocess
import sys
import tempfile

import yaml


# These files will be copied from the `rfc` repo to the handbook
ALLOWED_ASSET_FILE_EXTENSIONS = {
    '.jpg',
    '.md',  # only while some RFCs are split into subdocuments (not recommended)
    '.png',
    '.svg',
    '.webp',
}

# Don't change this or else we won't clean up old files correctly
AUTOGENERATED_MAGIC = 'Auto-generated by `handbook/scripts/aggregate-rfcs.py`'

AUTOGENERATED_COMMENT_TEMPLATE = f'# DO NOT EDIT! {AUTOGENERATED_MAGIC} from PLACEHOLDER - changes to this file will be overwritten!'

OLD_RFC_NUMBER_IN_TITLE_REGEX = re.compile(r'RFC \d+\s*(-\s*)?')

LINK_REGEX = re.compile(r'\]\(\.\./(?P<slug>[^/]+)/README\.md\)')

RFC_STATE_TO_SPAN = {
    'review': '<span style="color: darkorange">',
    'approved': '<span style="color: darkgreen; font-weight: bold">',
    'declined': '<span style="color: darkred; opacity: 0.8">',
    'obsolete': '<span style="color: darkgray; opacity: 0.8">',
}
RFC_STATE_TO_TITLE_SPAN = {
    'review': '<span>',
    'approved': '<span>',
    'declined': '<span style="opacity: 0.3">',
    'obsolete': '<span style="opacity: 0.3">',
}


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('rfc_repo_dir', help='Path to Git clone of https://github.com/giantswarm/rfc')
    parser.add_argument('output_dir', help='Output path for rendered RFCs')
    args = parser.parse_args()

    rfcs = []

    rfcs_json_file = tempfile.NamedTemporaryFile()
    subprocess.check_output([
        os.path.join(args.rfc_repo_dir, '.github', 'rfc-format', 'check-rfc-format.py'),
        '-o',
        rfcs_json_file.name,
        args.rfc_repo_dir,
    ])
    with open(rfcs_json_file.name, 'r') as f:
        rfcs = json.load(f)

    for rfc in rfcs:
        # Fix links between RFCs
        rfc['markdown_content_without_title'] = LINK_REGEX.sub(lambda m: ']({{< relref "/docs/rfcs/%s/" >}})' % m['slug'], rfc['markdown_content_without_title'])

        rfc['state_span'] = RFC_STATE_TO_SPAN[rfc['state']]
        rfc['title_span'] = RFC_STATE_TO_TITLE_SPAN[rfc['state']]

        rfc['creation_date_py'] = datetime.date.fromisoformat(rfc['creation_date'])

    output_index_file_path = os.path.join(args.output_dir, '_index.md')
    if not os.path.exists(output_index_file_path):
        raise RuntimeError(f'Invalid output directory {args.output_dir!r}, expected `_index.md` in that directory')

    # First capture which old content to delete in order to be idempotent
    files_to_delete = set()
    for root, dirs, files in os.walk(args.output_dir):
        for filename in files:
            file_path = os.path.join(root, filename)
            with open(file_path, encoding='utf-8', errors='replace') as f:
                content = f.read()
            if AUTOGENERATED_MAGIC in content:
                files_to_delete.add(os.path.normpath(file_path))

    # Create table of RFCs
    table = (
        '| Created (newest first) | Title | State |\n'
        '| ---------------------- | ----- | ----- |\n'
    )
    for rfc in sorted(rfcs, key=lambda rfc: (-(rfc['creation_date_py'] - datetime.date(1970, 1, 1)).total_seconds(), rfc['title'])):
        summary_opt = ''
        if rfc['summary']:
            summary_opt = f'<br><br><span style="opacity: 0.7">{rfc["summary"]}</span>'

        table += (
            f'| {rfc["creation_date"]} '
            f'| {rfc["title_span"]}[{rfc["title"]}](./{rfc["slug"]})</span>{summary_opt} '
            f'| {rfc["state_span"]}{rfc["state"]}</span> |\n'
        )
    with open(output_index_file_path, 'r+', encoding='utf-8') as f:
        content = f.read()

        regex = re.compile(r'(<!-- AUTOGENERATED RFC TABLE BEGIN -->\n).*(<!-- AUTOGENERATED RFC TABLE END -->\n)', flags=re.DOTALL)
        if not regex.search(content):
            raise RuntimeError(f'Did not find placeholders for RFC table in {output_index_file_path!r}')
        new_content = regex.sub(lambda m: m[1] + table.rstrip('\n') + '\n' + m[2], content)

        f.seek(0)
        f.write(new_content)
        f.truncate()

    # Create Markdown file per RFC
    for rfc in sorted(rfcs, key=lambda rfc: rfc['creation_date']):
        rfc_output_dir = os.path.join(args.output_dir, rfc['slug'])
        if not os.path.isdir(rfc_output_dir):
            os.mkdir(rfc_output_dir)

        summary_column = rfc['summary'] or '-'

        markdown_output_file_path = os.path.join(rfc_output_dir, f'_index.md')
        markdown_content = (
            '---\n'
            + AUTOGENERATED_COMMENT_TEMPLATE.replace(
                'PLACEHOLDER',
                f'https://github.com/giantswarm/rfc/tree/main/{rfc["slug"]}')
            + '\n'
            + yaml.dump({
                'hide_summary': True,
                'title': rfc['title'],
                'toc_hide': True,
            }, sort_keys=True, width=1000)
            + '---\n'
            + '\n'

            # Information from structured fields
            + f'| Created | State | Summary |\n'
            + '|-|-|-|\n'
            + f'| {rfc["creation_date"]} | {rfc["state_span"]}{rfc["state"]}</span> | {summary_column} |\n'
            + '\n'

            # Free-form content (note how YAML header `title` field will already product an H1 heading, so we leave it
            # off here)
            + rfc['markdown_content_without_title']
        )

        print(f'Updating file {markdown_output_file_path!r}')
        with open(markdown_output_file_path, 'w', encoding='utf-8') as out:
            out.write(markdown_content)

        files_to_delete.discard(os.path.normpath(markdown_output_file_path))

        # Also copy content files. Some RFCs are even separated into multiple Markdown files (not recommended, but let's
        # support it while we have that case).
        rfc_dir = os.path.join(args.rfc_repo_dir, rfc['slug'])
        for filename in os.listdir(rfc_dir):
            if filename == 'README.md':
                continue

            file_path = os.path.join(rfc_dir, filename)
            if not os.path.isfile(file_path):
                continue

            _, file_extension = os.path.splitext(filename)
            if file_extension not in ALLOWED_ASSET_FILE_EXTENSIONS:
                print(f'{rfc_dir}: Ignoring file {filename!r}')
                continue

            # Note that we don't delete/reconcile old files in the output directory here.
            # We can add that feature if cleanup is ever needed.
            print(f'{rfc_dir}: Copying asset file {filename!r}')
            shutil.copy(file_path, os.path.join(rfc_output_dir, filename))

    for file_path in files_to_delete:
        print(f'Deleting old file {file_path!r}')
        os.remove(file_path)


if __name__ == '__main__':
    sys.exit(main())
